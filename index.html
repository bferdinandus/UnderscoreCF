<!DOCTYPE html>
<html><head>
	<title>Underscore.cfc</title>
	<meta http-equiv="content-type" content="text/html; charset=UTF-8">
	<meta http-equiv="X-UA-Compatible" content="chrome=1">
	<meta name="viewport" content="width=device-width">
	<link rel="stylesheet" type="text/css" href="index_files/style.css">
</head>
<body>
	<div id="sidebar" class="interface">
		<a class="toc_title" href="#">
		    Underscore.cfc <span class="version">(2.4)</span>
	    </a>
	    <a class="toc_title" href="#">
	    	Introduction
	    </a>
    	
		    <a class="toc_title" href="#Collections">
			    Collections
		    </a>
			
		    <ul class="toc_section">
		    	<li>- <a href="#each">each</a></li><li>- <a href="#map">map</a></li><li>- <a href="#reduce">reduce</a></li><li>- <a href="#reduceRight">reduceRight</a></li><li>- <a href="#find">find</a></li><li>- <a href="#filter">filter</a></li><li>- <a href="#where">where</a></li><li>- <a href="#findWhere">findWhere</a></li><li>- <a href="#reject">reject</a></li><li>- <a href="#all">all</a></li><li>- <a href="#any">any</a></li><li>- <a href="#include">include</a></li><li>- <a href="#invoke">invoke</a></li><li>- <a href="#pluck">pluck</a></li><li>- <a href="#max">max</a></li><li>- <a href="#min">min</a></li><li>- <a href="#sortBy">sortBy</a></li><li>- <a href="#groupBy">groupBy</a></li><li>- <a href="#countBy">countBy</a></li><li>- <a href="#sortedIndex">sortedIndex</a></li><li>- <a href="#shuffle">shuffle</a></li><li>- <a href="#toArray">toArray</a></li><li>- <a href="#toQuery">toQuery</a></li><li>- <a href="#toXml">toXml</a></li><li>- <a href="#size">size</a></li>			    	
		    </ul>
    	
		    <a class="toc_title" href="#Arrays">
			    Arrays
		    </a>
			
		    <ul class="toc_section">
		    	<li>- <a href="#first">first</a></li><li>- <a href="#initial">initial</a></li><li>- <a href="#last">last</a></li><li>- <a href="#rest">rest</a></li><li>- <a href="#compact">compact</a></li><li>- <a href="#flatten">flatten</a></li><li>- <a href="#without">without</a></li><li>- <a href="#union">union</a></li><li>- <a href="#intersection">intersection</a></li><li>- <a href="#difference">difference</a></li><li>- <a href="#uniq">uniq</a></li><li>- <a href="#zip">zip</a></li><li>- <a href="#object">object</a></li><li>- <a href="#indexOf">indexOf</a></li><li>- <a href="#lastIndexOf">lastIndexOf</a></li><li>- <a href="#range">range</a></li><li>- <a href="#concat">concat</a></li><li>- <a href="#reverse">reverse</a></li><li>- <a href="#takeWhile">takeWhile</a></li><li>- <a href="#splice">splice</a></li><li>- <a href="#push">push</a></li><li>- <a href="#unshift">unshift</a></li><li>- <a href="#join">join</a></li><li>- <a href="#split">split</a></li><li>- <a href="#slice">slice</a></li>			    	
		    </ul>
    	
		    <a class="toc_title" href="#Functions">
			    Functions
		    </a>
			
		    <ul class="toc_section">
		    	<li>- <a href="#bind">bind</a></li><li>- <a href="#bindAll">bindAll</a></li><li>- <a href="#memoize">memoize</a></li><li>- <a href="#delay">delay</a></li><li>- <a href="#once">once</a></li><li>- <a href="#debounce">debounce</a></li><li>- <a href="#after">after</a></li><li>- <a href="#wrap">wrap</a></li><li>- <a href="#compose">compose</a></li>			    	
		    </ul>
    	
		    <a class="toc_title" href="#Objects">
			    Objects
		    </a>
			
		    <ul class="toc_section">
		    	<li>- <a href="#keys">keys</a></li><li>- <a href="#values">values</a></li><li>- <a href="#pairs">pairs</a></li><li>- <a href="#invert">invert</a></li><li>- <a href="#functions">functions</a></li><li>- <a href="#extend">extend</a></li><li>- <a href="#pick">pick</a></li><li>- <a href="#omit">omit</a></li><li>- <a href="#defaults">defaults</a></li><li>- <a href="#clone">clone</a></li><li>- <a href="#has">has</a></li><li>- <a href="#isEqual">isEqual</a></li><li>- <a href="#isEmpty">isEmpty</a></li><li>- <a href="#isArray">isArray</a></li><li>- <a href="#isObject">isObject</a></li><li>- <a href="#isFunction">isFunction</a></li><li>- <a href="#isString">isString</a></li><li>- <a href="#isNumber">isNumber</a></li><li>- <a href="#isBoolean">isBoolean</a></li><li>- <a href="#isDate">isDate</a></li>			    	
		    </ul>
    	
		    <a class="toc_title" href="#Utilities">
			    Utilities
		    </a>
			
		    <ul class="toc_section">
		    	<li>- <a href="#times">times</a></li><li>- <a href="#random">random</a></li><li>- <a href="#mixin">mixin</a></li><li>- <a href="#uniqueId">uniqueId</a></li><li>- <a href="#escape">escape</a></li><li>- <a href="#result">result</a></li>			    	
		    </ul>
    	
	    <a class="toc_title" href="#changelog">
	    	Change Log
	    </a>  	
	</div>
	<div class="container">
		<h1>Underscore.cfc</h1>
		<p id="Introduction">
			Underscore.cfc is a port of <a href="http://underscorejs.org/">Underscore.js</a>
 for Coldfusion. It is a utility-belt library that provides a lot of the
 functional programming support that you would expect in Prototype.js 
(or Ruby). <br><br>Underscore.cfc provides dozens of functions that 
support both the usual functional suspects: map, select, invoke - as 
well as more specialized helpers: function binding, sorting, deep 
equality testing, and so on. It delegates to built-in functions where 
applicable.<br><br>Underscore.cfc is compatible with Adobe Coldfusion 10 and Railo 4.<br><br>The project is <a href="http://github.com/russplaysguitar/underscorecf">hosted on GitHub</a>. Contributions are welcome.<br>
		</p>		
		<h2>Download</h2>
		<div><a href="https://github.com/russplaysguitar/UnderscoreCF/archive/v2.4.zip">Version 2.4</a> - <i>~40kb, Includes all development files</i></div>
		<h2 id="Collections">Collection Functions (Arrays, Structs, Queries, or Objects)</h2>
		

<p id="each"><b class="header">each</b> <code>_.each(collection, iterator, [context]) : void</code><br>Iterates
 over a collection of elements, yielding each in turn to an iterator 
function. The iterator is bound to the context object (component or 
struct), if one is passed. Each invocation of iterator is called with 
three arguments: (element, index, collection, this). If collection is an
 object/struct, iterator's arguments will be (value, key, collection, 
this).<br></p><pre>_.each([1, 2, 3], function(num){ writeDump(num); }); <br>=&gt; dumps each number in turn... <br>_.each({one : 1, two : 2, three : 3}, function(num, key){ writeDump(num); });<br>=&gt; dumps each number in turn...</pre><p></p>

<p id="map"><b class="header">map</b> <code>_.map(collection, iterator, [context]) : array</code><br>Produces
 a new array of values by mapping each value in collection through a 
transformation function (iterator). If collection is an object/struct, 
iterator's arguments will be (value, key, collection, this).<br></p><pre>_.map([1, 2, 3], function(num){ return num * 3; }); <br>=&gt; [3, 6, 9] <br>_.map({one : 1, two : 2, three : 3}, function(num, key){ return num * 3; });<br>=&gt; [3, 6, 9]</pre><p></p>

<p id="reduce"><b class="header">reduce</b> <code>_.reduce(collection, iterator, memo, [context]) : any</code><br>Also
 known as inject and foldl, reduce boils down a collection of values 
into a single value. Memo is the initial state of the reduction, and 
each successive step of it should be returned by iterator.<br></p><pre>sum = _.reduce([1, 2, 3], function(memo, num){ return memo + num; }, 0);<br>=&gt; 6</pre><p></p>

<p id="reduceRight"><b class="header">reduceRight</b> <code>_.reduceRight(collection, [iterator], memo, [context])</code><br>The right-associative version of reduce.<br></p><pre>list = [[0, 1], [2, 3], [4, 5]];<br>flat = _.reduceRight(list, function(a, b) { return _.concat(a, b); }, []);<br>=&gt; [4, 5, 2, 3, 0, 1]</pre><p></p>

<p id="find"><b class="header">find</b> <code>_.find(collection, iterator, [context]) : any</code><br>Looks
 through each value in the collection, returning the first one that 
passes a truth test (iterator). The function returns as soon as it finds
 an acceptable element, and doesn't traverse the entire collection.<br></p><pre>even = _.find([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });<br>=&gt; 2</pre><p></p>

<p id="filter"><b class="header">filter</b> <code>_.filter(collection, iterator, [context]) : array</code><br>Looks through each value in the collection, returning an array of all the values that pass a truth test (iterator).<br></p><pre>evens = _.filter([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });<br>=&gt; [2, 4, 6]</pre><p></p>

<p id="where"><b class="header">where</b> <code>_.where(list, properties) : array</code><br>Looks
 through each value in the list, returning an array of all the values 
that contain all of the key-value pairs listed in properties.<br></p><pre>_.where(listOfPlays, {author: "Shakespeare", year: 1611});<br>=&gt; [{title: "Cymbeline", author: "Shakespeare", year: 1611},<br>    {title: "The Tempest", author: "Shakespeare", year: 1611}]</pre><p></p>

<p id="findWhere"><b class="header">findWhere</b> <code>_.findWhere(collection, properties) : any</code><br>Looks through the collection and returns the first value that matches all of the key-value pairs listed in properties.<br></p><pre>_.findWhere(publicServicePulitzers, {newsroom: "The New York Times"});<br>=&gt; {year: 1918, newsroom: "The New York Times",<br>    reason: "For its public service in publishing in full so many official reports,<br>    documents and speeches by European statesmen relating to the progress and<br>    conduct of the war."}</pre><p></p>

<p id="reject"><b class="header">reject</b> <code>_.reject(collection, iterator, [context]) : array</code><br>Returns the values in collection without the elements that the truth test (iterator) passes. The opposite of filter.<br></p><pre>odds = _.reject([1, 2, 3, 4, 5, 6], function(num){ return num % 2 == 0; });<br>=&gt; [1, 3, 5]</pre><p></p>

<p id="all"><b class="header">all</b> <code>_.all(collection, iterator, [context]) : boolean</code><br>Returns true if all of the values in the collection pass the iterator truth test.<br></p><pre>_.all([true, 1, 'no'], _.identity);<br>=&gt; false</pre><p></p>

<p id="any"><b class="header">any</b> <code>_.any(collection, [iterator], [context]) : boolean</code><br>Returns
 true if any of the values in the collection pass the iterator truth 
test. Short-circuits and stops traversing the collection if a true 
element is found.<br></p><pre>_.any([0, 'yes', false]);<br>=&gt; true</pre><p></p>

<p id="include"><b class="header">include</b> <code>_.include(collection, value) : boolean</code><br>Returns true if the value is present in the collection.<br></p><pre>_.include([1, 2, 3], 3);<br>=&gt; true</pre><p></p>

<p id="invoke"><b class="header">invoke</b> <code>_.invoke(collection, methodName, [arguments]) : array</code><br>Calls
 the method named by methodName on each value in the collection. The 
arguments struct passed to invoke will be forwarded on to the method 
invocation.<br></p><pre>_.invoke([{fun: function(){ return 1; }}], 'fun');<br>=&gt; [1]</pre><p></p>

<p id="pluck"><b class="header">pluck</b> <code>_.pluck(collection, propertyName) : array</code><br>A convenient version of what is perhaps the most common use-case for map: extracting a collection of property values.<br></p><pre>stooges = [{name : 'moe', age : 40}, {name : 'larry', age : 50}, {name : 'curly', age : 60}];<br>_.pluck(stooges, 'name');<br>=&gt; ["moe", "larry", "curly"]</pre><p></p>

<p id="max"><b class="header">max</b> <code>_.max(collection, [iterator], [context]) : any</code><br>Returns
 the maximum value in collection. If iterator is passed, it will be used
 on each value to generate the criterion by which the value is ranked.<br></p><pre>stooges = [{name : 'moe', age : 40}, {name : 'larry', age : 50}, {name : 'curly', age : 60}];<br>_.max(stooges, function(stooge){ return stooge.age; });<br>=&gt; {name : 'curly', age : 60};</pre><p></p>

<p id="min"><b class="header">min</b> <code>_.min(collection, [iterator], [context]) : any</code><br>Returns
 the minimum value in collection. If iterator is passed, it will be used
 on each value to generate the criterion by which the value is ranked.<br></p><pre>numbers = [10, 5, 100, 2, 1000];<br>_.min(numbers);<br>=&gt; 2</pre><p></p>

<p id="sortBy"><b class="header">sortBy</b> <code>_.sortBy(collection, [iterator], [context]) : array</code><br>Returns
 a sorted copy of collection, ranked in ascending order by the results 
of running each value through iterator. Iterator may also be the string 
name of the object key to sort by. Delegates to arraySort().<br></p><pre>_.sortBy([6, 2, 4, 3, 5, 1], function(num){ return num; });<br>=&gt; [1, 2, 3, 4, 5, 6]</pre><p></p>

<p id="groupBy"><b class="header">groupBy</b> <code>_.groupBy(collection, iterator) : struct</code><br>Splits
 a collection into sets, grouped by the result of running each value 
through iterator. If iterator is a string instead of a function, groups 
by the property named by iterator on each of the values.<br></p><pre>_.groupBy([1.3, 2.1, 2.4], function(num){ return fix(num); });<br>=&gt; {1: [1.3], 2: [2.1, 2.4]}<br><br>_.groupBy(['one', 'two', 'three'], function(num) { return len(num); });<br>=&gt; {3: ["one", "two"], 5: ["three"]}</pre><p></p>

<p id="countBy"><b class="header">countBy</b> <code>_.countBy(collection, iterator) : struct</code><br>Sorts
 a collection into groups and returns a count for the number of objects 
in each group. Similar to groupBy, but instead of returning a list of 
values, returns a count for the number of values in that group.<br></p><pre>_.countBy([1, 2, 3, 4, 5], function(num) { return num % 2 == 0 ? 'even' : 'odd'; });<br>=&gt; {odd: 3, even: 2}</pre><p></p>

<p id="sortedIndex"><b class="header">sortedIndex</b> <code>_.sortedIndex(collection, value, [iterator]) : numeric</code><br>Uses
 a binary search to determine the index at which the value should be 
inserted into the collection in order to maintain the collection's 
sorted order. If an iterator is passed, it will be used to compute the 
sort ranking of each value.<br></p><pre>_.sortedIndex([10, 20, 30, 40, 50], 35);<br>=&gt; 4</pre><p></p>

<p id="shuffle"><b class="header">shuffle</b> <code>_.shuffle(array) : array</code><br>Returns a shuffled copy of the array, using a version of the Fisher-Yates shuffle.<br></p><pre>_.shuffle([1, 2, 3, 4, 5, 6]);<br>=&gt; [4, 1, 6, 3, 5, 2]</pre><p></p>

<p id="toArray"><b class="header">toArray</b> <code>_.toArray(collection) : array</code><br>Converts the collection (object, struct, query, xml, or cf-list), into an array.<br></p><pre>_.toArray({a:10,b:20});<br>=&gt; [10, 20]</pre><p></p>

<p id="toQuery"><b class="header">toQuery</b> <code>_.toQuery(array, [columnNames], [columnTypes]) : query</code><br>Converts
 an array of structs to a Coldfusion query. Columns are created 
dynamically unless a comma-delimited list of column names are provided. 
Column types are "varchar" unless a comma-delimited list of column types
 is provided. Delegates to native QueryNew().<br></p><pre>_.toQuery([{someColumn: "row 1"}]); <br>=&gt; (result is a query with one column titled "someColumn" and one row containing "row 1</pre><p></p>

<p id="toXml"><b class="header">toXml</b> <code>_.toXml(collection, [*elementNames]) : xml</code><br>Converts
 a collection to an XML object. Element names default to variable types.
 If provided, element names will be assigned to unnamed elements (any 
element without a key) in the order they are listed.<br></p><pre>_.toXml([1, 2]); <br>=&gt; &lt;array&gt;&lt;element&gt;1&lt;/element&gt;&lt;element&gt;2&lt;/element&gt;&lt;/array&gt; <br><br>_.toXml([3], 'myArray', 'number'); <br>=&gt; &lt;myArray&gt;&lt;number&gt;3&lt;/number&gt;&lt;myArray&gt;</pre><p></p>

<p id="size"><b class="header">size</b> <code>_.size(collection) : numeric</code><br>Return the number of values in the collection. Note: A simple value will be considered a single list item.<br></p><pre>_.size({one : 1, two : 2, three : 3});<br>=&gt; 3<br>_.size(99);<br>=&gt; 1<br>_.size("101");<br>=&gt; 1<br>_.size();<br>=&gt; 0</pre><p></p>
		<h2 id="Arrays">Array Functions</h2>
		

<p id="first"><b class="header">first</b> <code>_.first(array, [n]) : any</code><br>Returns the first element of an array. Passing n will return the first n elements of the array.<br></p><pre>_.first([5, 4, 3, 2, 1]);<br>=&gt; 5</pre><p></p>

<p id="initial"><b class="header">initial</b> <code>_.initial(array, [n]) : array</code><br>Returns
 everything but the last entry of the array. Especially useful on the 
arguments object. Pass n to exclude the last n elements from the result.
 Note: CF arrays start at an index of 1<br></p><pre>_.initial([5, 4, 3, 2, 1]);<br>=&gt; [5, 4, 3, 2]</pre><p></p>

<p id="last"><b class="header">last</b> <code>_.last(array, [n]) : any</code><br>Returns the last element of an array. Passing n will return the last n elements of the array.<br></p><pre>_.last([5, 4, 3, 2, 1]);<br>=&gt; 1</pre><p></p>

<p id="rest"><b class="header">rest</b> <code>_.rest(array, [index]) : array</code><br>Returns the rest of the elements in an array. Pass an index to return the values of the array from that index onward.<br></p><pre>_.rest([5, 4, 3, 2, 1]);<br>=&gt; [4, 3, 2, 1]</pre><p></p>

<p id="compact"><b class="header">compact</b> <code>_.compact(array) : array</code><br>Returns a copy of the array with all falsy values removed. In Coldfusion, false, 0, and "" are all falsy.<br></p><pre>_.compact([0, 1, false, 2, '', 3]);<br>=&gt; [1, 2, 3]</pre><p></p>

<p id="flatten"><b class="header">flatten</b> <code>_.flatten(array, [shallow]) : array</code><br>Flattens a nested array (the nesting can be to any depth). If you pass shallow, the array will only be flattened a single level.<br></p><pre>_.flatten([1, [2], [3, [[4]]]]);<br>=&gt; [1, 2, 3, 4];<br><br>_.flatten([1, [2], [3, [[4]]]], true);<br>=&gt; [1, 2, 3, [[4]]];</pre><p></p>

<p id="without"><b class="header">without</b> <code>_.without(array, [values]) : array</code><br>Returns a copy of the array with all instances of the values removed.<br></p><pre>_.without([1, 2, 1, 0, 3, 1, 4], [0, 1]);<br>=&gt; [2, 3, 4]</pre><p></p>

<p id="union"><b class="header">union</b> <code>_.union(*arrays) : array</code><br>Computes
 the union of the passed-in arrays: the collection of unique items, in 
order, that are present in one or more of the arrays.<br></p><pre>_.union([1, 2, 3], [101, 2, 1, 10], [2, 1]);<br>=&gt; [1, 2, 3, 101, 10]</pre><p></p>

<p id="intersection"><b class="header">intersection</b> <code>_.intersection(*arrays) : array</code><br>Computes
 the collection of values that are the intersection of all the arrays. 
Each value in the result is present in each of the arrays.<br></p><pre>_.intersection([1, 2, 3], [101, 2, 1, 10], [2, 1]);<br>=&gt; [1, 2]</pre><p></p>

<p id="difference"><b class="header">difference</b> <code>_.difference(array, others) : array</code><br>Similar to without, but returns the values from array that are not present in the other arrays.<br></p><pre>_.difference([1, 2, 3, 4, 5], [5, 2, 10]);<br>=&gt; [1, 3, 4]</pre><p></p>

<p id="uniq"><b class="header">uniq</b> <code>_.uniq(array, [isSorted], [iterator]) : array</code><br>Produces
 a duplicate-free version of the array. If you know in advance that the 
array is sorted, passing true for isSorted will run a much faster 
algorithm. If you want to compute unique items based on a 
transformation, pass an iterator function.<br></p><pre>_.uniq([1, 2, 1, 3, 1, 4]);<br>=&gt; [1, 2, 3, 4]</pre><p></p>

<p id="zip"><b class="header">zip</b> <code>_.zip(*arrays) : array</code><br>Merges
 together the values of each of the arrays with the values at the 
corresponding position. Useful when you have separate data sources that 
are coordinated through matching array indexes.<br></p><pre>_.zip(['moe', 'larry', 'curly'], [30, 40, 50], [true, false, false]);<br>=&gt; [["moe", 30, true], ["larry", 40, false], ["curly", 50, false]]</pre><p></p>

<p id="object"><b class="header">object</b> <code>_.object(array, [values])</code><br>Converts an array into a struct. Pass either a single array of [key, value] pairs, or an array of keys, and an array of values.<br></p><pre>_.object([['MYKEY', 'myVal']]);<br>=&gt; {MYKEY: 'myVal'}<br><br>_.object(['KEY'], ['myVal']);<br>=&gt; {KEY: 'value'}</pre><p></p>

<p id="indexOf"><b class="header">indexOf</b> <code>_.indexOf(array, value, [isSorted/fromIndex]) : numeric</code><br>Returns
 the index at which value can be found in the array, or 0 if value is 
not present in the array. Uses the native ArrayFind() function. If 
you're working with a large array, and you know that the array is 
already sorted, pass true for isSorted to use a faster binary search.<br></p><pre>_.indexOf([1, 2, 3], 2);<br>=&gt; 2</pre><p></p>

<p id="lastIndexOf"><b class="header">lastIndexOf</b> <code>_.lastIndexOf(array, value) : numeric</code><br>Returns the index of the last occurrence of value in the array, or 0 if value is not present.<br></p><pre>_.lastIndexOf([1, 2, 3, 1, 2, 3], 2);<br>=&gt; 5</pre><p></p>

<p id="range"><b class="header">range</b> <code>_.range([start], stop, [step]) : array</code><br>A
 function to create flexibly-numbered arrays of integers, handy for each
 and map loops. start, if omitted, defaults to 0; step defaults to 1. 
Returns an array of integers from start to stop, incremented (or 
decremented) by step, exclusive.<br></p><pre>_.range(10);<br>=&gt; [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]<br>_.range(1, 11);<br>=&gt; [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]<br>_.range(0, 30, 5);<br>=&gt; [0, 5, 10, 15, 20, 25]<br>_.range(0, -10, -1);<br>=&gt; [0, -1, -2, -3, -4, -5, -6, -7, -8, -9]<br>_.range(0);<br>=&gt; []</pre><p></p>

<p id="concat"><b class="header">concat</b> <code>_.concat(*arrays) : array</code><br>Concatenates any number of arrays together an returns the result. Delegates to ArrayAppend().<br></p><pre>_.concat([1, 2, 3], [4, 5, 6]);<br>=&gt; [1, 2, 3, 4, 5, 6];</pre><p></p>

<p id="reverse"><b class="header">reverse</b> <code>_.reverse(array) : array</code><br>Returns a copy of the array in reverse order.<br></p><pre>_.reverse([1, 2, 3]);<br>=&gt; [3, 2, 1]</pre><p></p>

<p id="takeWhile"><b class="header">takeWhile</b> <code>_.takeWhile(array) : array</code><br>Appends values to a new array as long as the iterator is true.<br></p><pre>_.takeWhile([1, 2, 3, 4, 1, 2], function(val) { return val &lt; 3; });<br>=&gt; [1, 2]</pre><p></p>

<p id="splice"><b class="header">splice</b> <code>_.splice(array, index, howMany, [*items]) : array</code><br>Returns
 a copy of the array with howMany elements removed. Optionally inserts 
items at the index. Note: differs from Javascript splice() in that it 
does not return the removed elements.<br></p><pre>_.splice([10, 90, 30], 2, 2);<br> =&gt; [10]<br>_.splice([10, 90, 30], 2, 1, 20);<br> =&gt; [10, 20, 30]</pre><p></p>

<p id="push"><b class="header">push</b> <code>_.push(array, *values) : array</code><br>Returns a new array with values appended to the end of it. Does not modify the original array.<br></p><pre>_.push([1, 2], 3, 4);<br>=&gt; [1, 2, 3, 4]</pre><p></p>

<p id="unshift"><b class="header">unshift</b> <code>_.unshift(array, *values) : array</code><br>Returns a new array with values prepended to the array. Does not modify the original array.<br></p><pre>_.unshift(["end"], "start", "middle");<br>=&gt; ["start", "middle", "end"]</pre><p></p>

<p id="join"><b class="header">join</b> <code>_.join(array, [separator]) : string</code><br>Returns a string with all array elements joined together. Default separator is a single space.<br></p><pre>_.join([1, 2], " and ");<br>=&gt; "1 and 2</pre><p></p>

<p id="split"><b class="header">split</b> <code>_.split(string, [delimiters], [includeEmptyFields], [multiCharacterDelimiter]) : array</code><br>Returns
 an array of strings from the string, separating the string at each of 
the delimeters passed to it (default is comma). Note: This is simply an 
alias for listToArray().<br></p><pre>_.split("hello", '');<br>=&gt; ['h', 'e', 'l', 'l', 'o']</pre><p></p>

<p id="slice"><b class="header">slice</b> <code>_.slice(array, [from], [to]) : array</code><br>Returns a subsection of the array. Negative values for to and from offset from the end of the array.<br></p><pre>_.slice([1, 2, 3, 4]);<br>=&gt; [2, 3, 4]<br><br>_.slice([1, 2, 3, 4], 3);<br>=&gt; [3, 4]<br><br>_.slice([1, 2, 3, 4], 2, -1);<br>=&gt; [2, 3]<br><br>_.slice([1, 2, 3, 4], -3, -1);<br>=&gt; [2, 3]</pre><p></p>
		<h2 id="Functions">Function (uh, ahem) Functions</h2>
		

<p id="bind"><b class="header">bind</b> <code>_.bind(function, object, [*arguments]) : function</code><br>Bind
 a function to a structure, meaning that whenever the function is 
called, the value of "this" will be the structure. Optionally, bind 
arguments to the function to pre-fill them, also known as partial 
application.<br></p><pre>func = function(args, this){ return args.greeting &amp; ': ' &amp; this.name; };<br>func = _.bind(func, {name : 'moe'}, {greeting: 'hi'});<br>func();<br>=&gt; 'hi: moe'</pre><p></p>

<p id="bindAll"><b class="header">bindAll</b> <code>_.bindAll(object, [*methodNames]) : any</code><br>Bind all of an object's methods to that object. Useful for ensuring that all callbacks defined on an object belong to it.<br></p><pre>greeter = {hello: 'Hello, ', greet: function(this){ return this.hello &amp; 'World!'; }};<br>_.bindAll(greeter);<br>greeter.greet();<br>=&gt; 'Hello, World!'</pre><p></p>

<p id="memoize"><b class="header">memoize</b> <code>_.memoize(function, [hashFunction]) : function</code><br>Memoizes
 a given function by caching the computed result. Useful for speeding up
 slow-running computations. If passed an optional hashFunction, it will 
be used to compute the hash key for storing the result, based on the 
arguments to the original function. The default hashFunction just uses 
the first argument to the memoized function as the key.<br></p><pre>fibonacci = _.memoize(function(n) {  return n &lt; 2 ? n : fibonacci(n - 1) + fibonacci(n - 2); });</pre><p></p>

<p id="delay"><b class="header">delay</b> <code>_.delay(function, wait, arguments) : any</code><br>Delays a function for the given number of milliseconds, and then calls it with the arguments supplied in the args struct.<br></p><pre>_.delay(function (msg) {return msg;}, 1000, {msg = "hi"});<br>=&gt; "hi" // appears after one second</pre><p></p>

<p id="once"><b class="header">once</b> <code>_.once(function) : function</code><br>Returns a function that will be executed at most one time, no matter how often you call it. Useful for lazy initialization.<br></p><pre>i = 0;<br>once = _.once(function () { i = i+1; return i; });<br>once();<br>=&gt; 1<br>once();<br>=&gt; 1</pre><p></p>

<p id="debounce"><b class="header">debounce</b> <code>_.debounce(function, wait, immediate) : function</code><br>Returns
 a function that, as long as it continues to be invoked, will not be 
triggered. The function will be called after it stops being called for N
 milliseconds. If immediate is passed, trigger the function on the 
leading edge, instead of the trailing. (Immediate requires a Wait 
cooldown period beteween calls.)<br></p><pre>keepCalm = _.debounce(function(){}, 300, true);<br>for (var i = 0; i&lt;10; i++){ keepCalm(); }<br>=&gt;//function argument is called only once</pre><p></p>

<p id="after"><b class="header">after</b> <code>_.after(count, function) : any</code><br>Returns
 a function that will only be executed after being called N times. When 
count &lt;= 0, the result of calling the function immediately is 
returned.<br></p><pre>func = function () { writeOutput("hi"); };<br>callFuncAfterTwo = _.after(2, func);<br>callFuncAfterTwo();<br>=&gt; // nothing<br>callFuncAfterTwo();<br>=&gt; 'hi'</pre><p></p>

<p id="wrap"><b class="header">wrap</b> <code>_.wrap(function, wrapper) : function</code><br>Returns
 the first function passed as an argument to the second, allowing you to
 adjust arguments, run code before and after, and conditionally execute 
the original function.<br></p><pre>hello = function(name) { return "hello: " &amp; name; };<br>hello = _.wrap(hello, function(func) {<br>return "before, " &amp; func("moe") &amp; ", after";<br>});<br>hello();<br>=&gt; 'before, hello: moe, after'</pre><p></p>

<p id="compose"><b class="header">compose</b> <code>_.compose(*functions) : function</code><br>Returns
 a function that is the composition of a list of functions, each 
function consumes the return value of the function that follows. In math
 terms, composing the functions f(), g(), and h() produces f(g(h())).<br></p><pre>greet	= function(name){ return "hi: " &amp; name; };<br>exclaim  = function(statement){ return statement &amp; "!"; };<br>welcome = _.compose(exclaim, greet);<br>welcome('moe');<br>=&gt; 'hi: moe!';</pre><p></p>
		<h2 id="Objects">Object/Struct Functions</h2>
		

<p id="keys"><b class="header">keys</b> <code>_.keys(object) : array</code><br>Retrieve all the names of the object's properties.<br></p><pre>_.keys({one : 1, two : 2, three : 3});<br>=&gt; ["one", "two", "three"]</pre><p></p>

<p id="values"><b class="header">values</b> <code>_.values(object) : array</code><br>Returns
 true if any of the values in the object pass the iterator truth test. 
Short-circuits and stops traversing the object if a true element is 
found.<br></p><pre>_.values({one : 1, two : 2, three : 3});<br>=&gt; [1, 2, 3]</pre><p></p>

<p id="pairs"><b class="header">pairs</b> <code>_.pairs(object) : array</code><br>Convert
 an object into a list of [key, value] pairs. Notes: Resulting item 
order is not guaranteed. Key capitalization will depend on your CF 
engine.<br></p><pre>_.pairs({ONE: 1, TWO: 2, THREE: 3});<br>=&gt; [["ONE", 1], ["TWO", 2], ["THREE", 3]]</pre><p></p>

<p id="invert"><b class="header">invert</b> <code>_.invert(object) : object</code><br>Returns
 a copy of the object where the keys have become the values and the 
values the keys. For this to work, all of your object's values should be
 unique and string serializable. Note: Capitalization will depend on 
your CF engine.<br></p><pre>_.invert({Moe: "Moses", Larry: "Louis", Curly: "Jerome"});<br>=&gt; {Moses: "Moe", Louis: "Larry", Jerome: "Curly"};</pre><p></p>

<p id="functions"><b class="header">functions</b> <code>_.functions(object) : array</code><br>Returns
 a sorted array of the names of every method in an object -- that is to 
say, the name of every function property of the object.<br></p><pre>_.functions(_);<br>=&gt; ["all", "any", "bind", "bindAll", "clone", "compact", "compose" ...</pre><p></p>

<p id="extend"><b class="header">extend</b> <code>_.extend(destination, *sources) : any</code><br>Copy
 all of the properties in the source objects over to the destination 
object, and return the destination object. It's in-order, so the last 
source will override properties of the same name in previous arguments.<br></p><pre>_.extend({name : 'moe'}, {age : 50});<br>=&gt; {name : 'moe', age : 50}</pre><p></p>

<p id="pick"><b class="header">pick</b> <code>_.pick(object, *keys) : struct</code><br>Return a copy of the object, filtered to only have values for the whitelisted keys (or array of valid keys).<br></p><pre>_.pick({name : 'moe', age: 50, userid : 'moe1'}, 'name', 'age');<br>=&gt; {name : 'moe', age : 50}</pre><p></p>

<p id="omit"><b class="header">omit</b> <code>_.omit(object, *keys) : struct</code><br>Return a copy of the object, filtered to omit the blacklisted keys (or array of keys).<br></p><pre>_.omit({NAME: 'moe', AGE: 50, USERID: 'moe1'}, 'userid');<br>=&gt; {NAME: 'moe', AGE: 50}</pre><p></p>

<p id="defaults"><b class="header">defaults</b> <code>_.defaults(object, *defaults) : any</code><br>Fill
 in missing properties in object with default values from the defaults 
objects, and return the object. As soon as the property is filled, 
further defaults will have no effect.<br></p><pre>iceCream = {flavor : "chocolate"};<br>_.defaults(iceCream, {flavor : "vanilla", sprinkles : "lots"});<br>=&gt; {flavor : "chocolate", sprinkles : "lots"}</pre><p></p>

<p id="clone"><b class="header">clone</b> <code>_.clone(object) : any</code><br>Create a shallow-copied clone of the object. Any nested structs or objects will be copied by reference, not duplicated.<br></p><pre>_.clone({name : 'moe'});<br>=&gt; {name : 'moe'}</pre><p></p>

<p id="has"><b class="header">has</b> <code>_.has(object, key) : boolean</code><br>Does the object contain the given key? Delegates to _.include() for arrays or native structKeyExists() for objects.<br></p><pre>_.has({a: 1, b: 2, c: 3}, "b");<br>=&gt; true</pre><p></p>

<p id="isEqual"><b class="header">isEqual</b> <code>_.isEqual(object, other)</code><br>Performs a deep comparison between the two objects, to determine if they should be considered equal.<br></p><pre>moe = {name : 'moe', luckyNumbers : [13, 27, 34]};<br>clone = {name : 'moe', luckyNumbers : [13, 27, 34]};<br>_.isEqual(moe, clone);<br>=&gt; true</pre><p></p>

<p id="isEmpty"><b class="header">isEmpty</b> <code>_.isEmpty(object) : boolean</code><br>Returns true if object contains no values. Delegates to ArrayLen for arrays, structIsEmpty() otherwise.<br></p><pre>_.isEmpty([1, 2, 3]);<br>=&gt; false<br>_.isEmpty({});<br>=&gt; true</pre><p></p>

<p id="isArray"><b class="header">isArray</b> <code>_.isArray(object) : boolean</code><br>Returns true if object is an Array. Delegates to native isArray();<br></p><pre>_.isArray({one: 1});<br>=&gt; false<br>_.isArray([1,2,3]);<br>=&gt; true</pre><p></p>

<p id="isObject"><b class="header">isObject</b> <code>_.isObject(object) : boolean</code><br>Returns true if value is an Object. Delegates to native isObject()<br></p><pre>_.isObject(new Component());<br>=&gt; true <br>_.isObject({});<br>=&gt; false</pre><p></p>

<p id="isFunction"><b class="header">isFunction</b> <code>_.isFunction(object) : boolean</code><br>Returns true if object is a Function.	Delegates to native isClosure() || isCustomFunction()<br></p><pre>_.isFunction(function(){return 1;});<br>=&gt; true</pre><p></p>

<p id="isString"><b class="header">isString</b> <code>_.isString(object) : boolean</code><br>Returns true if object is a String. Uses Java String type comparison.<br></p><pre>_.isString("moe");<br>=&gt; true<br>_.isString(1);<br>=&gt; true//Coldfusion converts numbers to strings</pre><p></p>

<p id="isNumber"><b class="header">isNumber</b> <code>_.isNumber(object) : boolean</code><br>Returns true if object is of a Java numeric type.<br></p><pre>_.isNumber(1);<br>=&gt; false//Coldfusion converts numbers to strings<br>_.isNumber(JavaCast("int", 1));<br>=&gt; true</pre><p></p>

<p id="isBoolean"><b class="header">isBoolean</b> <code>_.isBoolean(object) : boolean</code><br>Returns true if object is a boolean. Delegates to native isBoolean()<br></p><pre>_.isBoolean(false);<br>=&gt; true</pre><p></p>

<p id="isDate"><b class="header">isDate</b> <code>_.isDate(object) : boolean</code><br>Returns true if object is a date. Delegates to native isDate()<br></p><pre>_.isDate(now());<br>=&gt; true</pre><p></p>
		<h2 id="Utilities">Utility Functions</h2>
		

<p id="times"><b class="header">times</b> <code>_.times(n, iterator) : void</code><br>Invokes the given iterator function n times.<br></p><pre>_.times(3, function(){ genie.grantWish(); });</pre><p></p>

<p id="random"><b class="header">random</b> <code>_.random(min, max) : numeric</code><br>Returns
 a random integer between min and max, inclusive. If you only pass one 
argument, it will return a number between 0 and that number. Delegates 
to RandRange().<br></p><pre>_.random(0, 100);<br>=&gt; 42</pre><p></p>

<p id="mixin"><b class="header">mixin</b> <code>_.mixin(object) : void</code><br>Allows
 you to extend Underscore with your own utility functions. Pass a struct
 of {name: function} definitions to have your functions added to the 
Underscore object, <s>as well as the OOP wrapper.</s><br></p><pre>_.mixin({ <br>upper: function(string) { return uCase(string); }<br>});<br>_.upper("fabio");<br>=&gt; "Fabio"</pre><p></p>

<p id="uniqueId"><b class="header">uniqueId</b> <code>_.uniqueId([prefix]) : string</code><br>Generates an identifier that is unique for this instance of Underscore<br></p><pre>_.uniqueId('c');<br> =&gt; 'c1</pre><p></p>

<p id="escape"><b class="header">escape</b> <code>_.escape(input) : string</code><br>Escapes a string for insertion into HTML, replacing &amp;, &lt;, &gt;, and " characters. Delegates to HTMLeditFormat().<br></p><pre>_.escape('Curly, Larry &amp; Moe');<br> =&gt; "Curly, Larry &amp; Moe</pre><p></p>

<p id="result"><b class="header">result</b> <code>_.result(object, property) : any</code><br>If the value of the named property is a function then invoke it; otherwise, return it.<br></p><pre>object = {cheese: 'crumpets', stuff: function(){ return 'nonsense'; }};<br>_.result(object, 'cheese');<br>=&gt; "crumpets"<br>_.result(object, 'stuff');<br>=&gt; "nonsense"</pre><p></p>
		<p id="changelog">
			</p><h2>Change Log</h2>
			<p>
		      <b class="header">2.4</b> -- <small><i>Feb 3rd, 2014</i></small><br>
	        </p>	
	        <ul>
	        	<li>Added debounce(), findWhere(), toQuery(), toXml(), and split()</li>
	        	<li></li>
	        </ul>
			<p>
			</p><p>
		        <b class="header">2.3</b> -- <small><i>December 12th, 2012</i></small><br>
	        </p>	
	        <ul>
	        	<li>Updated slice to delegate to native arraySlice()</li>
	        	<li>Fixed mxunit testing expected/actual ordering</li>
	        	<li>Added handling for empty list values to toArray()</li>
	        	<li>Added value(), push(), pop(), shift(), unshift(), and join()</li>
	        	<li>Added fromIndex to lastIndexOf() and indexOf()</li>
	        	<li>Added countBy(), pairs(), invert(), random(), where(), omit(), and objects()</li>
	        	<li>Added Foundry support</li>
	        </ul>
			<p>
		        <b class="header">2.2</b> -- <small><i>August 10th, 2012</i></small><br>
	        </p>	
	        <ul>
	        	<li>Added splice(), uniqueId(), takeWhile(), and escape()</li>
	        	<li>Changed arrayConcat and arrayReverse to concat and reverse</li>
	        	<li>Implemented native arraySort for sortBy()</li>
	        	<li>Fixed iterator "key" parameter for Collection functions</li>
	        	<li>Fixed bind() argument mixup</li>
	        </ul>
			<p>
		        <b class="header">2.1</b> -- <small><i>July 9th, 2012</i></small><br>
	        </p>	
	        <ul>
	        	<li>Fixed indexOf() index not found inconsistency</li>
	        	<li>Fixed iterator function indices for filter() and reject()</li>
	        	<li>Fixed Object clone and nested array clone</li>
	        </ul>
			<p>
		        <b class="header">2.0</b> -- <small><i>July 4th, 2012</i></small><br>
	        </p>	
	        <ul>
	        	<li>Added Railo 4 Support!</li>
	        	<li>Breaking changes: "this" now needs to be listed in the parameters of any iterator that references a passed in context.</li>
	        	<li>Cleaned up some writeDumps()</li>
	        	<li>Replaced isDefined() calls</li>
	        </ul>
			<p>
		        <b class="header">1.0</b> -- <small><i>June 30, 2012</i></small><br>
	        </p>
	        <ul>
	        	<li>
	        		First release! In under 30 days, woot!
		        </li>
	        </ul>
		<p></p>		
	</div>
	<a href="http://github.com/russplaysguitar/underscorecf"><img style="position: absolute; top: 0; right: 0; border: 0;" src="index_files/forkme_right_darkblue_121621.png" alt="Fork me on GitHub"></a>

</body></html>